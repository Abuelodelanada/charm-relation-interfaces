"""Runner script to execute all interface tests."""
# Copyright 2023 Canonical Ltd.
# See LICENSE file for licensing details.

import json
import logging
import os
import shutil
import subprocess
import sys
from collections import namedtuple
from pathlib import Path
from typing import Tuple

from interface_tester.collector import _CharmTestConfig, collect_tests

# it is "python -m venv" on some platforms/python versions
MKVENV_CMD = os.getenv("MKVENV_CMD", "python -m virtualenv")

FIXTURE_PATH = "tests/interface/conftest.py"
FIXTURE_IDENTIFIER = "interface_tester"
logging.getLogger().setLevel(logging.INFO)

FixtureSpec = namedtuple('FixtureSpec', 'path id')


class SetupError(Exception):
    pass


class InterfaceTestError(Exception):
    pass


def _clone_charm_repo(charm_config: _CharmTestConfig, charm_path: Path):
    """Clones a charm repository to a local path."""
    branch_option = ""
    if charm_config.branch:
        branch_option = f"--branch {charm_config.branch}"
        logging.warning(f"custom branch provided for {charm_config.name}; "
                        f"this should only be done in staging")
    subprocess.call(
        f"git clone --quiet --depth 1 {branch_option} {charm_config.url} {charm_path}",
        shell=True,
        stdout=subprocess.DEVNULL
    )


def prepare_repo(
        charm_config: _CharmTestConfig,
        interface: str,
        root: Path = Path("/tmp/charm-relation-interfaces-tests/"),
) -> Tuple[Path, Path]:
    """Clone the charm repository and create the venv if it hasn't been done already."""
    charm_path = root / Path(charm_config.name)
    if not charm_path.exists():
        _clone_charm_repo(charm_config, charm_path)
        _setup_venv(charm_path)
    try:
        fixture_spec = _get_fixture(charm_config, charm_path)
    except FileNotFoundError as e:
        raise SetupError(f"unable to get fixture spec from {charm_path}") from e
    if not fixture_spec.path.is_file():
        # NOTE: In the future we could probably run the tests without a fixture, assuming
        # that the charm needs no patching at all to work with scenario
        raise SetupError(f"fixture missing for charm {charm_config.name}")
    test_path = _generate_test(interface, fixture_spec.path.parent, fixture_spec.id)
    return charm_path, test_path


def _clean(root: Path = Path("/tmp/charm-relation-interfaces-tests/")):
    """Clean the directory used to store repos for the tests."""
    if root.is_dir():
        shutil.rmtree(root)


TEST_CONTENT = """
# file generated by run_matrix.py
from interface_tester import InterfaceTester
def test_{interface}_interface({fixture_id}: InterfaceTester):
    {fixture_id}.configure(
        interface_name="{interface}",
    )
    {fixture_id}.run()
"""


def _generate_test(interface: str, test_path: Path, fixture_id: str) -> Path:
    """Generate a pytest file for a given charm and interface."""
    test_content = TEST_CONTENT.format(interface=interface, fixture_id=fixture_id)
    test_filename = f"interface-test-{interface}.py"
    with open(test_path / test_filename, "w") as file:
        file.write(test_content)
    return test_path / test_filename


def _get_fixture(charm_config: _CharmTestConfig, charm_path: Path) -> FixtureSpec:
    """Get the tester fixture from a charm."""
    fixture_path = charm_path / FIXTURE_PATH
    fixture_id = FIXTURE_IDENTIFIER
    if charm_config.test_setup:
        if charm_config.test_setup["location"]:
            fixture_path = charm_path / Path(charm_config.test_setup["location"])
        if charm_config.test_setup["identifier"]:
            fixture_id = charm_config.test_setup["identifier"]
    return FixtureSpec(fixture_path, fixture_id)


def _setup_venv(charm_path: Path) -> Path:
    """Create the venv for a charm and return the path to its python."""
    logging.info(f"Installing dependencies in venv for {charm_path}")
    original_wd = os.getcwd()
    os.chdir(charm_path)
    # Create the venv and install the requirements
    try:
        subprocess.check_call(f"{MKVENV_CMD} ./.interface-venv", shell=True, stdout=subprocess.DEVNULL)
        subprocess.check_call(
            ".interface-venv/bin/python -m pip install setuptools pytest git+https://github.com/canonical/interface-tester-pytest@main",
            shell=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        subprocess.check_call(
            ".interface-venv/bin/python -m pip install -r requirements.txt",
            shell=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
    except subprocess.CalledProcessError as e:
        raise SetupError("venv setup failed") from e
    os.chdir(original_wd)
    return charm_path / ".interface-venv/bin/python"


def run_interface_tests_on_charm(charm_path: Path, test_path: Path):
    """Run the interface test for a given charm and interface."""
    logging.info(f"Running tests for {charm_path}")
    original_wd = os.getcwd()
    os.chdir(charm_path)
    try:
        subprocess.check_call(
            f"PYTHONPATH=src:lib .interface-venv/bin/python -m pytest {test_path}",
            shell=True
        )
    except subprocess.CalledProcessError as e:
        raise InterfaceTestError from e
    os.chdir(original_wd)


def run_interface_tests(path: Path, include: str = "*") -> dict:
    """Run the tests for the specified interfaces, defaulting to all."""
    _clean()
    test_results = {}
    collected = collect_tests(path=path, include=include)
    for interface, version_to_roles in collected.items():
        test_results[interface] = {}
        logging.info(f"Running tests for interface: {interface}")
        for _, role_to_collected in version_to_roles.items():
            for role in ["provider", "requirer"]:
                test_results[interface][role] = {}
                if not role_to_collected[role]['tests']:
                    logging.info(f"No tests specified for {interface}:{role}")
                    continue

                charms_to_test = role_to_collected[role]["charms"]

                if not charms_to_test:
                    logging.info(f"No charms registered for {interface}:{role}")
                    continue

                logging.info(f"Running tests for {interface}:{role}")

                for charm_config in charms_to_test:
                    success = 1
                    logging.info(f"Charm: {charm_config.name}")
                    try:
                        charm_path, test_path = prepare_repo(charm_config, interface)
                    except SetupError:
                        logging.warning(f"test setup failed for {charm_config.name} {interface} {role}", exc_info=True)
                        success = 0
                    if success:
                        try:
                            run_interface_tests_on_charm(charm_path, test_path)
                        except InterfaceTestError:
                            logging.warning(f"interface tests for {charm_config.name} {interface} {role} failed",
                                            exc_info=True)
                            success = 0
                    test_results[interface][role][charm_config.name] = success
                    logging.info(f"Result: {success}")

    if not collected:
        logging.warning('No tests collected.')

    return test_results


def pprint_interface_test_results(test_results: dict):
    """Pretty print the results of interface tests."""
    print("+++ Results +++")
    print(json.dumps(test_results, indent=2))


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--include",
        default="*",
        help="Glob to filter what interfaces to include in the test matrix."
    )
    args = parser.parse_args()

    pprint_interface_test_results(
        run_interface_tests(Path("."), args.include)
    )
